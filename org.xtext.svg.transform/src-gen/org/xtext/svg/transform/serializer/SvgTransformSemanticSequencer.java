/*
 * generated by Xtext 2.12.0
 */
package org.xtext.svg.transform.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.svg.transform.services.SvgTransformGrammarAccess;
import svg.Matrix;
import svg.Rotate;
import svg.Scale;
import svg.SkewX;
import svg.SkewY;
import svg.SvgPackage;
import svg.Transform;
import svg.Translate;

@SuppressWarnings("all")
public class SvgTransformSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SvgTransformGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SvgPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SvgPackage.MATRIX:
				sequence_Matrix(context, (Matrix) semanticObject); 
				return; 
			case SvgPackage.ROTATE:
				sequence_Rotate(context, (Rotate) semanticObject); 
				return; 
			case SvgPackage.SCALE:
				sequence_Scale(context, (Scale) semanticObject); 
				return; 
			case SvgPackage.SKEW_X:
				sequence_SkewX(context, (SkewX) semanticObject); 
				return; 
			case SvgPackage.SKEW_Y:
				sequence_SkewY(context, (SkewY) semanticObject); 
				return; 
			case SvgPackage.TRANSFORM:
				sequence_Transform(context, (Transform) semanticObject); 
				return; 
			case SvgPackage.TRANSLATE:
				sequence_Translate(context, (Translate) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TransformValue returns Matrix
	 *     Matrix returns Matrix
	 *
	 * Constraint:
	 *     (
	 *         a=Number 
	 *         b=Number 
	 *         c=Number 
	 *         d=Number 
	 *         e=Number 
	 *         f=Number
	 *     )
	 */
	protected void sequence_Matrix(ISerializationContext context, Matrix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.MATRIX__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.MATRIX__A));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.MATRIX__B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.MATRIX__B));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.MATRIX__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.MATRIX__C));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.MATRIX__D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.MATRIX__D));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.MATRIX__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.MATRIX__E));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.MATRIX__F) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.MATRIX__F));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatrixAccess().getANumberParserRuleCall_2_0(), semanticObject.getA());
		feeder.accept(grammarAccess.getMatrixAccess().getBNumberParserRuleCall_4_0(), semanticObject.getB());
		feeder.accept(grammarAccess.getMatrixAccess().getCNumberParserRuleCall_6_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getMatrixAccess().getDNumberParserRuleCall_8_0(), semanticObject.getD());
		feeder.accept(grammarAccess.getMatrixAccess().getENumberParserRuleCall_10_0(), semanticObject.getE());
		feeder.accept(grammarAccess.getMatrixAccess().getFNumberParserRuleCall_12_0(), semanticObject.getF());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransformValue returns Rotate
	 *     Rotate returns Rotate
	 *
	 * Constraint:
	 *     (a=Number (x=Number y=Number)?)
	 */
	protected void sequence_Rotate(ISerializationContext context, Rotate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformValue returns Scale
	 *     Scale returns Scale
	 *
	 * Constraint:
	 *     (x=Number y=Number?)
	 */
	protected void sequence_Scale(ISerializationContext context, Scale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformValue returns SkewX
	 *     SkewX returns SkewX
	 *
	 * Constraint:
	 *     a=Number
	 */
	protected void sequence_SkewX(ISerializationContext context, SkewX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.SKEW_X__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.SKEW_X__A));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkewXAccess().getANumberParserRuleCall_2_0(), semanticObject.getA());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransformValue returns SkewY
	 *     SkewY returns SkewY
	 *
	 * Constraint:
	 *     a=Number
	 */
	protected void sequence_SkewY(ISerializationContext context, SkewY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.SKEW_Y__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.SKEW_Y__A));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkewYAccess().getANumberParserRuleCall_2_0(), semanticObject.getA());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Transform returns Transform
	 *
	 * Constraint:
	 *     (transform+=TransformValue transform+=TransformValue*)
	 */
	protected void sequence_Transform(ISerializationContext context, Transform semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformValue returns Translate
	 *     Translate returns Translate
	 *
	 * Constraint:
	 *     (x=Number y=Number?)
	 */
	protected void sequence_Translate(ISerializationContext context, Translate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
