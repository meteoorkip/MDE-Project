/*
 * generated by Xtext 2.12.0
 */
package org.xtext.svg.path.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.svg.path.services.SvgPathGrammarAccess;
import svg.AbsoluteCubicCurveTo;
import svg.AbsoluteHorizontalLineTo;
import svg.AbsoluteLineTo;
import svg.AbsoluteMoveTo;
import svg.AbsoluteQuadraticCurveTo;
import svg.AbsoluteSmoothCubicCurveTo;
import svg.AbsoluteSmoothQuadraticCurveTo;
import svg.AbsoluteVerticalLineTo;
import svg.ClosePath;
import svg.Path;
import svg.RelativeCubicCurveTo;
import svg.RelativeHorizontalLineTo;
import svg.RelativeLineTo;
import svg.RelativeMoveTo;
import svg.RelativeQuadraticCurveTo;
import svg.RelativeSmoothCubicCurveTo;
import svg.RelativeSmoothQuadraticCurveTo;
import svg.RelativeVerticalLineTo;
import svg.SvgPackage;

@SuppressWarnings("all")
public class SvgPathSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SvgPathGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SvgPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SvgPackage.ABSOLUTE_CUBIC_CURVE_TO:
				sequence_AbsoluteCubicCurveTo(context, (AbsoluteCubicCurveTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_HORIZONTAL_LINE_TO:
				sequence_AbsoluteHorizontalLineTo(context, (AbsoluteHorizontalLineTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_LINE_TO:
				sequence_AbsoluteLineTo(context, (AbsoluteLineTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_MOVE_TO:
				sequence_AbsoluteMoveTo(context, (AbsoluteMoveTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_QUADRATIC_CURVE_TO:
				sequence_AbsoluteQuadraticCurveTo(context, (AbsoluteQuadraticCurveTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO:
				sequence_AbsoluteSmoothCubicCurveTo(context, (AbsoluteSmoothCubicCurveTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_SMOOTH_QUADRATIC_CURVE_TO:
				sequence_AbsoluteSmoothQuadraticCurveTo(context, (AbsoluteSmoothQuadraticCurveTo) semanticObject); 
				return; 
			case SvgPackage.ABSOLUTE_VERTICAL_LINE_TO:
				sequence_AbsoluteVerticalLineTo(context, (AbsoluteVerticalLineTo) semanticObject); 
				return; 
			case SvgPackage.CLOSE_PATH:
				sequence_ClosePath(context, (ClosePath) semanticObject); 
				return; 
			case SvgPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_CUBIC_CURVE_TO:
				sequence_RelativeCubicCurveTo(context, (RelativeCubicCurveTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_HORIZONTAL_LINE_TO:
				sequence_RelativeHorizontalLineTo(context, (RelativeHorizontalLineTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_LINE_TO:
				sequence_RelativeLineTo(context, (RelativeLineTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_MOVE_TO:
				sequence_RelativeMoveTo(context, (RelativeMoveTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_QUADRATIC_CURVE_TO:
				sequence_RelativeQuadraticCurveTo(context, (RelativeQuadraticCurveTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_SMOOTH_CUBIC_CURVE_TO:
				sequence_RelativeSmoothCubicCurveTo(context, (RelativeSmoothCubicCurveTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_SMOOTH_QUADRATIC_CURVE_TO:
				sequence_RelativeSmoothQuadraticCurveTo(context, (RelativeSmoothQuadraticCurveTo) semanticObject); 
				return; 
			case SvgPackage.RELATIVE_VERTICAL_LINE_TO:
				sequence_RelativeVerticalLineTo(context, (RelativeVerticalLineTo) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteCubicCurveTo
	 *     AbsoluteCubicCurveTo returns AbsoluteCubicCurveTo
	 *
	 * Constraint:
	 *     (
	 *         c1x=Number 
	 *         c1y=Number 
	 *         c2x=Number 
	 *         c2y=Number 
	 *         x=Number 
	 *         y=Number
	 *     )
	 */
	protected void sequence_AbsoluteCubicCurveTo(ISerializationContext context, AbsoluteCubicCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C1X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C1X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C1Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C1Y));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C2X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C2X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C2Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__C2Y));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_CUBIC_CURVE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteCubicCurveToAccess().getC1xNumberParserRuleCall_1_0(), semanticObject.getC1x());
		feeder.accept(grammarAccess.getAbsoluteCubicCurveToAccess().getC1yNumberParserRuleCall_3_0(), semanticObject.getC1y());
		feeder.accept(grammarAccess.getAbsoluteCubicCurveToAccess().getC2xNumberParserRuleCall_5_0(), semanticObject.getC2x());
		feeder.accept(grammarAccess.getAbsoluteCubicCurveToAccess().getC2yNumberParserRuleCall_7_0(), semanticObject.getC2y());
		feeder.accept(grammarAccess.getAbsoluteCubicCurveToAccess().getXNumberParserRuleCall_9_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAbsoluteCubicCurveToAccess().getYNumberParserRuleCall_11_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteHorizontalLineTo
	 *     AbsoluteHorizontalLineTo returns AbsoluteHorizontalLineTo
	 *
	 * Constraint:
	 *     x=Number
	 */
	protected void sequence_AbsoluteHorizontalLineTo(ISerializationContext context, AbsoluteHorizontalLineTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_HORIZONTAL_LINE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_HORIZONTAL_LINE_TO__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteHorizontalLineToAccess().getXNumberParserRuleCall_1_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteLineTo
	 *     AbsoluteLineTo returns AbsoluteLineTo
	 *
	 * Constraint:
	 *     (x=Number y=Number)
	 */
	protected void sequence_AbsoluteLineTo(ISerializationContext context, AbsoluteLineTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_LINE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_LINE_TO__X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_LINE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_LINE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteLineToAccess().getXNumberParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAbsoluteLineToAccess().getYNumberParserRuleCall_3_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteMoveTo
	 *     AbsoluteMoveTo returns AbsoluteMoveTo
	 *
	 * Constraint:
	 *     (x=Number y=Number)
	 */
	protected void sequence_AbsoluteMoveTo(ISerializationContext context, AbsoluteMoveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_MOVE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_MOVE_TO__X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_MOVE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_MOVE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteMoveToAccess().getXNumberParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAbsoluteMoveToAccess().getYNumberParserRuleCall_3_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteQuadraticCurveTo
	 *     AbsoluteQuadraticCurveTo returns AbsoluteQuadraticCurveTo
	 *
	 * Constraint:
	 *     (cx=Number cy=Number x=Number y=Number)
	 */
	protected void sequence_AbsoluteQuadraticCurveTo(ISerializationContext context, AbsoluteQuadraticCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__CX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__CX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__CY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__CY));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_QUADRATIC_CURVE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteQuadraticCurveToAccess().getCxNumberParserRuleCall_1_0(), semanticObject.getCx());
		feeder.accept(grammarAccess.getAbsoluteQuadraticCurveToAccess().getCyNumberParserRuleCall_3_0(), semanticObject.getCy());
		feeder.accept(grammarAccess.getAbsoluteQuadraticCurveToAccess().getXNumberParserRuleCall_5_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAbsoluteQuadraticCurveToAccess().getYNumberParserRuleCall_7_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteSmoothCubicCurveTo
	 *     AbsoluteSmoothCubicCurveTo returns AbsoluteSmoothCubicCurveTo
	 *
	 * Constraint:
	 *     (cx=Number cy=Number x=Number y=Number)
	 */
	protected void sequence_AbsoluteSmoothCubicCurveTo(ISerializationContext context, AbsoluteSmoothCubicCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__CX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__CX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__CY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__CY));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_CUBIC_CURVE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteSmoothCubicCurveToAccess().getCxNumberParserRuleCall_1_0(), semanticObject.getCx());
		feeder.accept(grammarAccess.getAbsoluteSmoothCubicCurveToAccess().getCyNumberParserRuleCall_3_0(), semanticObject.getCy());
		feeder.accept(grammarAccess.getAbsoluteSmoothCubicCurveToAccess().getXNumberParserRuleCall_5_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAbsoluteSmoothCubicCurveToAccess().getYNumberParserRuleCall_7_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteSmoothQuadraticCurveTo
	 *     AbsoluteSmoothQuadraticCurveTo returns AbsoluteSmoothQuadraticCurveTo
	 *
	 * Constraint:
	 *     (x=Number y=Number)
	 */
	protected void sequence_AbsoluteSmoothQuadraticCurveTo(ISerializationContext context, AbsoluteSmoothQuadraticCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_QUADRATIC_CURVE_TO__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_QUADRATIC_CURVE_TO__X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_QUADRATIC_CURVE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_SMOOTH_QUADRATIC_CURVE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteSmoothQuadraticCurveToAccess().getXNumberParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAbsoluteSmoothQuadraticCurveToAccess().getYNumberParserRuleCall_3_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns AbsoluteVerticalLineTo
	 *     AbsoluteVerticalLineTo returns AbsoluteVerticalLineTo
	 *
	 * Constraint:
	 *     y=Number
	 */
	protected void sequence_AbsoluteVerticalLineTo(ISerializationContext context, AbsoluteVerticalLineTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.ABSOLUTE_VERTICAL_LINE_TO__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.ABSOLUTE_VERTICAL_LINE_TO__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsoluteVerticalLineToAccess().getYNumberParserRuleCall_1_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns ClosePath
	 *     ClosePath returns ClosePath
	 *
	 * Constraint:
	 *     {ClosePath}
	 */
	protected void sequence_ClosePath(ISerializationContext context, ClosePath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (path+=PathValue path+=PathValue*)
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeCubicCurveTo
	 *     RelativeCubicCurveTo returns RelativeCubicCurveTo
	 *
	 * Constraint:
	 *     (
	 *         dc1x=Number 
	 *         dc1y=Number 
	 *         dc2x=Number 
	 *         dc2y=Number 
	 *         dx=Number 
	 *         dy=Number
	 *     )
	 */
	protected void sequence_RelativeCubicCurveTo(ISerializationContext context, RelativeCubicCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC1X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC1X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC1Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC1Y));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC2X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC2X));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC2Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DC2Y));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_CUBIC_CURVE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeCubicCurveToAccess().getDc1xNumberParserRuleCall_1_0(), semanticObject.getDc1x());
		feeder.accept(grammarAccess.getRelativeCubicCurveToAccess().getDc1yNumberParserRuleCall_3_0(), semanticObject.getDc1y());
		feeder.accept(grammarAccess.getRelativeCubicCurveToAccess().getDc2xNumberParserRuleCall_5_0(), semanticObject.getDc2x());
		feeder.accept(grammarAccess.getRelativeCubicCurveToAccess().getDc2yNumberParserRuleCall_7_0(), semanticObject.getDc2y());
		feeder.accept(grammarAccess.getRelativeCubicCurveToAccess().getDxNumberParserRuleCall_9_0(), semanticObject.getDx());
		feeder.accept(grammarAccess.getRelativeCubicCurveToAccess().getDyNumberParserRuleCall_11_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeHorizontalLineTo
	 *     RelativeHorizontalLineTo returns RelativeHorizontalLineTo
	 *
	 * Constraint:
	 *     dx=Number
	 */
	protected void sequence_RelativeHorizontalLineTo(ISerializationContext context, RelativeHorizontalLineTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_HORIZONTAL_LINE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_HORIZONTAL_LINE_TO__DX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeHorizontalLineToAccess().getDxNumberParserRuleCall_1_0(), semanticObject.getDx());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeLineTo
	 *     RelativeLineTo returns RelativeLineTo
	 *
	 * Constraint:
	 *     (dx=Number dy=Number)
	 */
	protected void sequence_RelativeLineTo(ISerializationContext context, RelativeLineTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_LINE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_LINE_TO__DX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_LINE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_LINE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeLineToAccess().getDxNumberParserRuleCall_1_0(), semanticObject.getDx());
		feeder.accept(grammarAccess.getRelativeLineToAccess().getDyNumberParserRuleCall_3_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeMoveTo
	 *     RelativeMoveTo returns RelativeMoveTo
	 *
	 * Constraint:
	 *     (dx=Number dy=Number)
	 */
	protected void sequence_RelativeMoveTo(ISerializationContext context, RelativeMoveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_MOVE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_MOVE_TO__DX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_MOVE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_MOVE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeMoveToAccess().getDxNumberParserRuleCall_1_0(), semanticObject.getDx());
		feeder.accept(grammarAccess.getRelativeMoveToAccess().getDyNumberParserRuleCall_3_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeQuadraticCurveTo
	 *     RelativeQuadraticCurveTo returns RelativeQuadraticCurveTo
	 *
	 * Constraint:
	 *     (dcx=Number dcy=Number dx=Number dy=Number)
	 */
	protected void sequence_RelativeQuadraticCurveTo(ISerializationContext context, RelativeQuadraticCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DCX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DCX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DCY));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_QUADRATIC_CURVE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeQuadraticCurveToAccess().getDcxNumberParserRuleCall_1_0(), semanticObject.getDcx());
		feeder.accept(grammarAccess.getRelativeQuadraticCurveToAccess().getDcyNumberParserRuleCall_3_0(), semanticObject.getDcy());
		feeder.accept(grammarAccess.getRelativeQuadraticCurveToAccess().getDxNumberParserRuleCall_5_0(), semanticObject.getDx());
		feeder.accept(grammarAccess.getRelativeQuadraticCurveToAccess().getDyNumberParserRuleCall_7_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeSmoothCubicCurveTo
	 *     RelativeSmoothCubicCurveTo returns RelativeSmoothCubicCurveTo
	 *
	 * Constraint:
	 *     (dcx=Number dcy=Number dx=Number dy=Number)
	 */
	protected void sequence_RelativeSmoothCubicCurveTo(ISerializationContext context, RelativeSmoothCubicCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DCX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DCX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DCY));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_CUBIC_CURVE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeSmoothCubicCurveToAccess().getDcxNumberParserRuleCall_1_0(), semanticObject.getDcx());
		feeder.accept(grammarAccess.getRelativeSmoothCubicCurveToAccess().getDcyNumberParserRuleCall_3_0(), semanticObject.getDcy());
		feeder.accept(grammarAccess.getRelativeSmoothCubicCurveToAccess().getDxNumberParserRuleCall_5_0(), semanticObject.getDx());
		feeder.accept(grammarAccess.getRelativeSmoothCubicCurveToAccess().getDyNumberParserRuleCall_7_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeSmoothQuadraticCurveTo
	 *     RelativeSmoothQuadraticCurveTo returns RelativeSmoothQuadraticCurveTo
	 *
	 * Constraint:
	 *     (dx=Number dy=Number)
	 */
	protected void sequence_RelativeSmoothQuadraticCurveTo(ISerializationContext context, RelativeSmoothQuadraticCurveTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_QUADRATIC_CURVE_TO__DX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_QUADRATIC_CURVE_TO__DX));
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_QUADRATIC_CURVE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_SMOOTH_QUADRATIC_CURVE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeSmoothQuadraticCurveToAccess().getDxNumberParserRuleCall_1_0(), semanticObject.getDx());
		feeder.accept(grammarAccess.getRelativeSmoothQuadraticCurveToAccess().getDyNumberParserRuleCall_3_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathValue returns RelativeVerticalLineTo
	 *     RelativeVerticalLineTo returns RelativeVerticalLineTo
	 *
	 * Constraint:
	 *     dy=Number
	 */
	protected void sequence_RelativeVerticalLineTo(ISerializationContext context, RelativeVerticalLineTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SvgPackage.Literals.RELATIVE_VERTICAL_LINE_TO__DY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SvgPackage.Literals.RELATIVE_VERTICAL_LINE_TO__DY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeVerticalLineToAccess().getDyNumberParserRuleCall_1_0(), semanticObject.getDy());
		feeder.finish();
	}
	
	
}
